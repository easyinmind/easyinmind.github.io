(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{421:function(t,e,s){"use strict";s.r(e);var a=s(21),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"类组件和函数组件-无状态组件、展示组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类组件和函数组件-无状态组件、展示组件"}},[t._v("#")]),t._v(" 类组件和函数组件（无状态组件、展示组件）")]),t._v(" "),s("p",[t._v("函数组件相比类组件，性能要稍高一些，因为类组件需要实例化，函数组件直接执行即可。"),s("br"),t._v("\n函数组件没有"),s("code",[t._v("state")]),t._v("、"),s("code",[t._v("生命周期")]),t._v("及"),s("code",[t._v("this")]),t._v("。注：react hooks除外")]),t._v(" "),s("h2",{attrs:{id:"受控组件和非受控组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#受控组件和非受控组件"}},[t._v("#")]),t._v(" 受控组件和非受控组件")]),t._v(" "),s("p",[t._v("控制组件，针对表单来说。"),s("br"),t._v("\n受控组件需要将表单的value值于state绑定，并通过change事件setState，改变state的值。由React控制值，在改变的过程中可以对值进行处理。"),s("br"),t._v("\n非受控组件，不进行state的绑定，通过真实dom获取表单元素的value值，使用ref或者form 的 submit事件里获取。使用表单本身的状态逻辑，由 DOM 处理表单数据的地方，而不是在 React 组件中。"),s("br"),t._v("\n尽量使用受控组件。")]),t._v(" "),s("h2",{attrs:{id:"高阶组件hoc-纯组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件hoc-纯组件"}},[t._v("#")]),t._v(" 高阶组件HOC（纯组件）")]),t._v(" "),s("p",[t._v("接受一个组件并返回一个新的组件；")]),t._v(" "),s("ul",[s("li",[t._v("渲染劫持")]),t._v(" "),s("li",[t._v("代码重用")])]),t._v(" "),s("h2",{attrs:{id:"异步组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步组件"}},[t._v("#")]),t._v(" 异步组件")]),t._v(" "),s("p",[t._v("通过import()")]),t._v(" "),s("h2",{attrs:{id:"构造函数调用super并传入props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数调用super并传入props"}},[t._v("#")]),t._v(" 构造函数调用super并传入props")]),t._v(" "),s("blockquote",[s("p",[t._v("区别在于构造函数内调用super之后能不能使用this.props")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyComponent")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// super();")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// console.log(this.props);  // undefined")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// console.log(props);  // 有值")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// super(props);")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// console.log(this.props);  // 有值")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// console.log(props);  // 有值")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 有值，super()与super(props)在构造函数外部不受影响")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("h2",{attrs:{id:"state-props"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#state-props"}},[t._v("#")]),t._v(" state/props")]),t._v(" "),s("p",[t._v("都是js对象，state是组件自己管理的数据，可变。props是外部传入的数据，不可变。"),s("br"),t._v("\n有state的组件是有状态组件，无state的组件是无状态组件。"),s("br"),t._v("\n多用无状态组件。")]),t._v(" "),s("h2",{attrs:{id:"jsx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[t._v("#")]),t._v(" JSX")]),t._v(" "),s("p",[t._v("React发布提出的语法（模板语法？），将html和js结合，浏览器不认识，需要webpackbabel转为js。")]),t._v(" "),s("h2",{attrs:{id:"避免组件重新渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免组件重新渲染"}},[t._v("#")]),t._v(" 避免组件重新渲染")]),t._v(" "),s("p",[t._v("React.memo() 防止函数组件不必要的渲染；"),s("br"),t._v("\nPureComponent 防止类组件不必要的渲染；\n原理是通过传入组件的props进行浅比较，如果props没有改变则不渲染。使用不当会带来额外的性能开销。"),s("br"),t._v("\nshouldcomponentupdate;")]),t._v(" "),s("h2",{attrs:{id:"setstate同步异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate同步异步"}},[t._v("#")]),t._v(" setState同步异步")]),t._v(" "),s("p",[t._v("只要进入react的调度流程，就是异步的。setTimeout、setInterval、在DOM上绑定原生事件都不会进入React的调度流程。"),s("br"),t._v("\nsetState被调用后悔进入一个逻辑函数，判断当前react所处的阶段executionContext是否是 NoContext （空闲），如果是则会同步执行setState。\nexecutionContext的初始值就是NoContext，所以只要不进入react的调度流程 setState就是同步的。"),s("br"),t._v("\nuseState与setSatet同理；")]),t._v(" "),s("h2",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),s("p",[t._v("初始化阶段: constructor()，在 constructor 中进行 state、props 的初始化，在这个阶段修改 state，不会执行更新阶段的生命周期，可以直接对 state 赋值"),s("br"),t._v("\n挂载阶段: componentWillMount(未挂载 Dom) -> render -> componentDidMount(已经挂载 Dom)\n更新阶段:")]),t._v(" "),s("ul",[s("li",[t._v("componentWillReceiveProps(nextProps,nextState) state更新不会触发，props更新会触发。在这个方法中改变 state 不会二次渲染，而是直接合并 state。")]),t._v(" "),s("li",[t._v("shouldComponentUpdate(nextProps,nextState) 返回false会阻止向下的生命周期执行，默认返回true; 不能执行setState();")]),t._v(" "),s("li",[t._v("componentWillUpdate(nextProps,nextState) 不能执行setState();")]),t._v(" "),s("li",[t._v("render")]),t._v(" "),s("li",[t._v("componentDidUpdate(prevProps, prevState)")])]),t._v(" "),s("p",[t._v("卸载阶段: componentWillUnmount 清除定时器，卸载Dom事件")]),t._v(" "),s("p",[t._v("16.3版本 变化\n去除： componentWillMount、componentWillReceiveProps、componentWillUpdate\n增加：")]),t._v(" "),s("ul",[s("li",[t._v("static getDerivedStateFromProps(props, state)\n"),s("ul",[s("li",[t._v("挂载阶段render前执行")]),t._v(" "),s("li",[t._v("更新阶段: props更新后直接执行（16.3）、setState()调用后及forceUpdate()调用后执行（16.4）")])])]),t._v(" "),s("li",[t._v("getSnapshotBeforeUpdate(prevProps, prevState)\n"),s("ul",[s("li",[t._v("更新阶段render()后执行")])])])]),t._v(" "),s("h2",{attrs:{id:"新生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新生命周期"}},[t._v("#")]),t._v(" 新生命周期")]),t._v(" "),s("ul",[s("li",[t._v("挂载\n"),s("ul",[s("li",[t._v("constructor")]),t._v(" "),s("li",[t._v("getDerivedStateFromProps")]),t._v(" "),s("li",[t._v("render")]),t._v(" "),s("li",[t._v("componentDidMount")])])]),t._v(" "),s("li",[t._v("更新\n"),s("ul",[s("li",[t._v("getDerivedStateFromProps")]),t._v(" "),s("li",[t._v("shouldComponentUpdate")]),t._v(" "),s("li",[t._v("render")]),t._v(" "),s("li",[t._v("getSnapshotBeforeUpdate")]),t._v(" "),s("li",[t._v("componentDidUpdate")])])]),t._v(" "),s("li",[t._v("卸载")]),t._v(" "),s("li",[t._v("componentWillUnmount")])]),t._v(" "),s("h2",{attrs:{id:"组件渲染过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件渲染过程"}},[t._v("#")]),t._v(" 组件渲染过程")]),t._v(" "),s("p",[t._v("总结：父组件调用render之后开始执行子组件对应周期（首次渲染render、父组件状态修改触发render）的方法，等子组件对应周期的方法执行完之后，再执行父组件的后续方法。")]),t._v(" "),s("ul",[s("li",[t._v("挂载阶段，只有当执行到render的时候，子组件的constructor才开始执行，直到子组件挂载完成（componentDidMount），父组件才算挂载完成")]),t._v(" "),s("li",[t._v("更新阶段，类似挂载阶段，只有父组件执行到render，才开始子组件的getDerivedStateFromProps -> shouldComponentUpdate -> render，但再父组件的getSnapshotBeforeUpdate是紧随在子组件的getSnapshotBeforeUpdate后，然后子组件在componentDidUpdate")]),t._v(" "),s("li",[t._v("父组件调用forceUpdate，组件调用forceUpdate方法后，不会执行shouldComponentUpdate，会执行getDerivedStateFromProps，然后再render，后面的生命周期和更新一致")])]),t._v(" "),s("h2",{attrs:{id:"context"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[t._v("#")]),t._v(" context")]),t._v(" "),s("p",[t._v("作用： 当你不想在组件树种逐层传递props和state时，可以使用context跨层传递数据。")]),t._v(" "),s("h2",{attrs:{id:"在哪里调用请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在哪里调用请求"}},[t._v("#")]),t._v(" 在哪里调用请求")]),t._v(" "),s("p",[t._v("componentDidMount中调用")]),t._v(" "),s("ul",[s("li",[t._v("比在componentWillMoun中调用节省的时间非常少")]),t._v(" "),s("li",[t._v("服务端渲染will执行两次")]),t._v(" "),s("li",[t._v("fiber后，will可能中断")]),t._v(" "),s("li",[t._v("will会被废弃")])]),t._v(" "),s("h2",{attrs:{id:"为何会废弃-componentwillmount、-componentwillreceiveprops、-componentwillupdate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为何会废弃-componentwillmount、-componentwillreceiveprops、-componentwillupdate"}},[t._v("#")]),t._v(" 为何会废弃 componentWillMount、 componentWillReceiveProps、 componentWillUpdate")]),t._v(" "),s("ul",[s("li",[t._v("三个函数都是执行在render之前，fiber架构会中断执行，导致多次执行")]),t._v(" "),s("li",[t._v("React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码\n"),s("ul",[s("li",[t._v("componentWillMount可以完全适应componentDidMount和constructor来代替")]),t._v(" "),s("li",[t._v("componentWillReceiveProps新的替代方法是静态方法，没有this，写不出副作用")])])])]),t._v(" "),s("h2",{attrs:{id:"fiber"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" fiber")])])}),[],!1,null,null,null);e.default=n.exports}}]);