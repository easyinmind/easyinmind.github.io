(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{426:function(v,_,a){"use strict";a.r(_);var e=a(21),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[v._v("#")]),v._v(" 浏览器缓存")]),v._v(" "),a("blockquote",[a("p",[v._v("可以理解为浏览器有一个缓存表，存在资源和请求的对应关系和规则，每次发请求前先去查找有没有缓存，在根据规则使用对应的缓存")])]),v._v(" "),a("p",[v._v("优点：")]),v._v(" "),a("ol",[a("li",[v._v("减少了冗余的数据传递，节省宽带流量")]),v._v(" "),a("li",[v._v("减少了服务器的负担，大大提高了网站性能")]),v._v(" "),a("li",[v._v("加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因")])]),v._v(" "),a("h2",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[v._v("#")]),v._v(" HTTP 缓存")]),v._v(" "),a("ol",[a("li",[v._v("主要有"),a("em",[v._v("强缓存")]),v._v("、"),a("em",[v._v("协商缓存")])]),v._v(" "),a("li",[a("em",[v._v("强缓存")]),v._v("优先级高于"),a("em",[v._v("协商缓存")])]),v._v(" "),a("li",[a("em",[v._v("强缓存")]),v._v("不与服务器通信，即客户端进行判断")]),v._v(" "),a("li",[a("em",[v._v("协商缓存")]),v._v("与服务器通信，即服务端进行判断")])]),v._v(" "),a("h2",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),a("blockquote",[a("p",[v._v("根据响应头中的 "),a("em",[v._v("Expires")]),v._v(" 和 "),a("em",[v._v("Cache-Control")]),v._v(" 字段来控制，判断是否命中缓存，如果命中则不予服务器发生通信（灰色 200状态码）")])]),v._v(" "),a("ul",[a("li",[a("em",[v._v("Expires")]),v._v(": "),a("code",[v._v("Wed, 11 Sep 2019 16:12:18 GMT")]),v._v(" "),a("ul",[a("li",[v._v("http/1.0 采用绝对时间判断资源是否过期")]),v._v(" "),a("li",[v._v("缺点：因为绝对时间是服务器返回的，浏览器请求的时候会根据浏览器的时间进行对比，对客户端时间与服务器时间之间的一致性提出了极高的要求")])])]),v._v(" "),a("li",[a("em",[v._v("cache-control")]),v._v(": "),a("code",[v._v("max-age=31536000")]),v._v("多少秒后失效\n"),a("ul",[a("li",[v._v("http/1.1 采用相对时间（秒）判断资源是否过期")]),v._v(" "),a("li",[v._v("客户端会记录请求的时间作为起始时间，再次请求时获取当前时间与max-age值对比判断")]),v._v(" "),a("li",[v._v("起始时间和当前时间都来源于客户端，判断更准确")])])]),v._v(" "),a("li",[v._v("Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。")])]),v._v(" "),a("h2",{attrs:{id:"cache-control的其它值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-control的其它值"}},[v._v("#")]),v._v(" Cache-Control的其它值")]),v._v(" "),a("blockquote",[a("p",[v._v("值用逗号分隔")])]),v._v(" "),a("ul",[a("li",[a("em",[v._v("s-maxage")]),v._v(": s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。")]),v._v(" "),a("li",[a("em",[v._v("public")]),v._v(": 资源能被代理服务器和客户端缓存")]),v._v(" "),a("li",[a("em",[v._v("private")]),v._v(": 默认值，资源只能被客户端缓存")]),v._v(" "),a("li",[a("em",[v._v("no-store")]),v._v(": 使用协商缓存")]),v._v(" "),a("li",[a("em",[v._v("no-cache")]),v._v(": 不使用任何缓存策略")])]),v._v(" "),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),a("blockquote",[a("p",[v._v("浏览器需要向服务器送法请求信息询问缓存是否有效，如果有效资源会被重定向到浏览器缓存（304 Not Modified）")])]),v._v(" "),a("h2",{attrs:{id:"通过时间戳-服务器文件最后修改时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过时间戳-服务器文件最后修改时间"}},[v._v("#")]),v._v(" 通过时间戳，服务器文件最后修改时间")]),v._v(" "),a("ul",[a("li",[a("em",[v._v("Last-Modified")]),v._v(": 时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回"),a("code",[v._v("Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT")])]),v._v(" "),a("li",[a("em",[v._v("If-Modified-Since")]),v._v(":  后面的请求头会带上这个字段，值正是上一次 response 返回给它的 last-modified 值"),a("code",[v._v("If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT")])]),v._v(" "),a("li",[v._v("服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段")]),v._v(" "),a("li",[v._v("缺点：If-Modified-Since只能检测最小为秒单位的时间差、只对比文件最后修改时间，不对比内容")])]),v._v(" "),a("h2",{attrs:{id:"通过唯一的标识字符串-服务器基于文件内容生成的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过唯一的标识字符串-服务器基于文件内容生成的"}},[v._v("#")]),v._v(" 通过唯一的标识字符串，服务器基于文件内容生成的")]),v._v(" "),a("ul",[a("li",[a("em",[v._v("Etag")]),v._v(": 响应头中，服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。"),a("code",[v._v('ETag: W/"2a3b-1602480f459"')])]),v._v(" "),a("li",[a("em",[v._v("If-None-Match")]),v._v(": 请求头，每次请求都会带上，值为Etag的值。供服务端比对。"),a("code",[v._v('If-None-Match: W/"2a3b-1602480f459"')])]),v._v(" "),a("li",[v._v("缺点：Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在")]),v._v(" "),a("li",[v._v("Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准")])]),v._v(" "),a("h2",{attrs:{id:"缓存流程-策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存流程-策略"}},[v._v("#")]),v._v(" 缓存流程（策略）")]),v._v(" "),a("blockquote",[a("p",[v._v("一般推荐按照这种流程设置缓存策略")])]),v._v(" "),a("h2",{attrs:{id:"强缓存-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存-2"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),a("p",[v._v("查看缓存数据库")]),v._v(" "),a("ol",[a("li",[v._v("命中: 缓存未失效返回资源副本（灰色200），不与服务器通信")]),v._v(" "),a("li",[v._v("未命中: 缓存失效，请求服务器，返回资源和缓存规则，浏览器存储资源和缓存规则，供下次使用")]),v._v(" "),a("li")]),v._v(" "),a("h2",{attrs:{id:"协商缓存-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存-2"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),a("p",[v._v("客户端会先从缓存数据库中获取到一个缓存数据的标识（服务器返回的），放在请求头中，服务器判断是否命中")]),v._v(" "),a("ol",[a("li",[v._v("命中: 通知客户端有效（304），客户端从缓存数据库取资源副本")]),v._v(" "),a("li",[v._v("未命中: 返回资源和缓存规则，浏览器存储资源和缓存规则，供下次使用")])]),v._v(" "),a("p",[v._v("两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。")]),v._v(" "),a("h2",{attrs:{id:"优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[v._v("#")]),v._v(" 优先级")]),v._v(" "),a("p",[v._v("cache-control > Expires > Etag > Last-Modified")]),v._v(" "),a("h2",{attrs:{id:"对应关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对应关系"}},[v._v("#")]),v._v(" 对应关系")]),v._v(" "),a("ul",[a("li",[v._v("Expires：服务器返回，浏览器记录，并判断")]),v._v(" "),a("li",[v._v("cache-control：服务器返回，浏览器记录，并判断")]),v._v(" "),a("li",[v._v("Last-Modified：服务器返回，浏览器记录，请求带上 If-Modified-Since，服务器判断")]),v._v(" "),a("li",[v._v("Etag：服务器返回，浏览器记录，请求带上 If-None-Match，服务器判断")])]),v._v(" "),a("h2",{attrs:{id:"判断规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断规则"}},[v._v("#")]),v._v(" 判断规则")]),v._v(" "),a("ul",[a("li",[v._v("Expires：客户端根据绝对时间判断\n"),a("ul",[a("li",[v._v("值是服务器返回的绝对时间，浏览器根据当前的请求时间判断是否过期，服务器时间和客户端时间。")])])]),v._v(" "),a("li",[v._v("cache-control：客户端判断\n"),a("ul",[a("li",[v._v("max-age：客户端根据两次请求相对时间差判断\n"),a("ul",[a("li",[v._v("值为相对时间（秒），浏览器根据这次请求时间和上次请求时间差判断是否过期，客户端时间和客户端时间。")])])]),v._v(" "),a("li",[v._v("no-store：直接使用协商缓存")]),v._v(" "),a("li",[v._v("no-cache：不使用任何缓存策略")])])]),v._v(" "),a("li",[v._v("Last-Modified：服务端根据文件最后修改时间判断")]),v._v(" "),a("li",[v._v("Etag：服务端根据文件是否改动判断")])]),v._v(" "),a("h2",{attrs:{id:"更新缓存规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新缓存规则"}},[v._v("#")]),v._v(" 更新缓存规则")]),v._v(" "),a("ul",[a("li",[v._v("客户端会更新服务端返回的最新规则和数据到缓存表里")])]),v._v(" "),a("h2",{attrs:{id:"刷新规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#刷新规则"}},[v._v("#")]),v._v(" 刷新规则")]),v._v(" "),a("ul",[a("li",[v._v("输入URL：正常流程")]),v._v(" "),a("li",[v._v("刷新：使用协商缓存")]),v._v(" "),a("li",[v._v("强制刷新：删除缓存文件，重新请求数据")])]),v._v(" "),a("h2",{attrs:{id:"其它知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它知识点"}},[v._v("#")]),v._v(" 其它知识点")]),v._v(" "),a("ul",[a("li",[v._v("from Memory Cache: 浏览器缓存到内存的数据，读取快，内存很小，一般会缓存base64、小图片等资源")]),v._v(" "),a("li",[v._v("from disk Cache: 浏览器缓存到硬盘的数据，缓存较大的js、css等")]),v._v(" "),a("li",[v._v("Push Cache: http2.0特性\n"),a("ul",[a("li",[v._v("Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache")]),v._v(" "),a("li",[v._v("存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。")]),v._v(" "),a("li",[v._v("不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。")])])]),v._v(" "),a("li",[v._v("Service Worker Cache: 离线缓存，Server Worker 对协议是有要求的，必须以 https 协议为前提")])])])}),[],!1,null,null,null);_.default=t.exports}}]);