<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React相关概念简述 | easyinmind</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="前端技术博客,干货,前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.c6f546a7.css" as="style"><link rel="preload" href="/assets/js/app.9480acd0.js" as="script"><link rel="preload" href="/assets/js/2.60fa7d2d.js" as="script"><link rel="preload" href="/assets/js/8.f6479d16.js" as="script"><link rel="prefetch" href="/assets/js/10.22e8dbde.js"><link rel="prefetch" href="/assets/js/11.e2c317b3.js"><link rel="prefetch" href="/assets/js/12.f562f434.js"><link rel="prefetch" href="/assets/js/13.9925c33e.js"><link rel="prefetch" href="/assets/js/14.eac5bd40.js"><link rel="prefetch" href="/assets/js/15.5c51ebc8.js"><link rel="prefetch" href="/assets/js/16.57fc322f.js"><link rel="prefetch" href="/assets/js/17.04e9a84d.js"><link rel="prefetch" href="/assets/js/18.c7f5f16b.js"><link rel="prefetch" href="/assets/js/19.6b712fc4.js"><link rel="prefetch" href="/assets/js/20.b3f3ae39.js"><link rel="prefetch" href="/assets/js/21.78625a1b.js"><link rel="prefetch" href="/assets/js/22.08a94de9.js"><link rel="prefetch" href="/assets/js/23.0d2843cc.js"><link rel="prefetch" href="/assets/js/24.bd3424b1.js"><link rel="prefetch" href="/assets/js/25.d6f86ce8.js"><link rel="prefetch" href="/assets/js/26.2f653999.js"><link rel="prefetch" href="/assets/js/27.0cad2ac4.js"><link rel="prefetch" href="/assets/js/28.f5a7b7e9.js"><link rel="prefetch" href="/assets/js/29.98cff323.js"><link rel="prefetch" href="/assets/js/3.6eb2a58a.js"><link rel="prefetch" href="/assets/js/30.542b23fc.js"><link rel="prefetch" href="/assets/js/4.75bcf19e.js"><link rel="prefetch" href="/assets/js/5.55c4a00e.js"><link rel="prefetch" href="/assets/js/6.08b80b79.js"><link rel="prefetch" href="/assets/js/7.ed541a6c.js"><link rel="prefetch" href="/assets/js/9.a97dacf2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c6f546a7.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open no-sidebar have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/blog-photo.jpg" alt="easyinmind" class="logo"> <span class="site-name can-hide">easyinmind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="/pages/bjdct/" class="nav-link">北京的春天</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/1024x1024.jpg"> <div class="blogger-info"><h3>DBY</h3> <span>学无止境</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于我</a></div><div class="nav-item"><a href="/pages/bjdct/" class="nav-link">北京的春天</a></div> <!----></nav>  <!----> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-33863c7e><div class="articleInfo" data-v-33863c7e><ul class="breadcrumbs" data-v-33863c7e><li data-v-33863c7e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-33863c7e></a></li> <li data-v-33863c7e><a href="/categories/?category=%E6%8A%80%E6%9C%AF" title="分类" data-v-33863c7e>技术</a></li> <li data-v-33863c7e><a href="/categories/?category=%E5%89%8D%E7%AB%AF" title="分类" data-v-33863c7e>前端</a></li> <!----></ul> <div class="info" data-v-33863c7e><div title="作者" class="author iconfont icon-touxiang" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>dby</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>2021-06-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><!----> <h1><!---->
          React相关概念简述
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="类组件和函数组件-无状态组件、展示组件"><a href="#类组件和函数组件-无状态组件、展示组件" class="header-anchor">#</a> 类组件和函数组件（无状态组件、展示组件）</h2> <p>函数组件相比类组件，性能要稍高一些，因为类组件需要实例化，函数组件直接执行即可。<br>
函数组件没有<code>state</code>、<code>生命周期</code>及<code>this</code>。注：react hooks除外</p> <h2 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="header-anchor">#</a> 受控组件和非受控组件</h2> <p>控制组件，针对表单来说。<br>
受控组件需要将表单的value值于state绑定，并通过change事件setState，改变state的值。由React控制值，在改变的过程中可以对值进行处理。<br>
非受控组件，不进行state的绑定，通过真实dom获取表单元素的value值，使用ref或者form 的 submit事件里获取。使用表单本身的状态逻辑，由 DOM 处理表单数据的地方，而不是在 React 组件中。<br>
尽量使用受控组件。</p> <h2 id="高阶组件hoc-纯组件"><a href="#高阶组件hoc-纯组件" class="header-anchor">#</a> 高阶组件HOC（纯组件）</h2> <p>接受一个组件并返回一个新的组件；</p> <ul><li>渲染劫持</li> <li>代码重用</li></ul> <h2 id="异步组件"><a href="#异步组件" class="header-anchor">#</a> 异步组件</h2> <p>通过import()</p> <h2 id="构造函数调用super并传入props"><a href="#构造函数调用super并传入props" class="header-anchor">#</a> 构造函数调用super并传入props</h2> <blockquote><p>区别在于构造函数内调用super之后能不能使用this.props</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// super();</span>
    <span class="token comment">// console.log(this.props);  // undefined</span>
    <span class="token comment">// console.log(props);  // 有值</span>

    <span class="token comment">// super(props);</span>
    <span class="token comment">// console.log(this.props);  // 有值</span>
    <span class="token comment">// console.log(props);  // 有值</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token comment">// 有值，super()与super(props)在构造函数外部不受影响</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="state-props"><a href="#state-props" class="header-anchor">#</a> state/props</h2> <p>都是js对象，state是组件自己管理的数据，可变。props是外部传入的数据，不可变。<br>
有state的组件是有状态组件，无state的组件是无状态组件。<br>
多用无状态组件。</p> <h2 id="jsx"><a href="#jsx" class="header-anchor">#</a> JSX</h2> <p>React发布提出的语法（模板语法？），将html和js结合，浏览器不认识，需要webpackbabel转为js。</p> <h2 id="避免组件重新渲染"><a href="#避免组件重新渲染" class="header-anchor">#</a> 避免组件重新渲染</h2> <p>React.memo() 防止函数组件不必要的渲染；<br>
PureComponent 防止类组件不必要的渲染；
原理是通过传入组件的props进行浅比较，如果props没有改变则不渲染。使用不当会带来额外的性能开销。<br>
shouldcomponentupdate;</p> <h2 id="setstate同步异步"><a href="#setstate同步异步" class="header-anchor">#</a> setState同步异步</h2> <p>只要进入react的调度流程，就是异步的。setTimeout、setInterval、在DOM上绑定原生事件都不会进入React的调度流程。<br>
setState被调用后悔进入一个逻辑函数，判断当前react所处的阶段executionContext是否是 NoContext （空闲），如果是则会同步执行setState。
executionContext的初始值就是NoContext，所以只要不进入react的调度流程 setState就是同步的。<br>
useState与setSatet同理；</p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>初始化阶段: constructor()，在 constructor 中进行 state、props 的初始化，在这个阶段修改 state，不会执行更新阶段的生命周期，可以直接对 state 赋值<br>
挂载阶段: componentWillMount(未挂载 Dom) -&gt; render -&gt; componentDidMount(已经挂载 Dom)
更新阶段:</p> <ul><li>componentWillReceiveProps(nextProps,nextState) state更新不会触发，props更新会触发。在这个方法中改变 state 不会二次渲染，而是直接合并 state。</li> <li>shouldComponentUpdate(nextProps,nextState) 返回false会阻止向下的生命周期执行，默认返回true; 不能执行setState();</li> <li>componentWillUpdate(nextProps,nextState) 不能执行setState();</li> <li>render</li> <li>componentDidUpdate(prevProps, prevState)</li></ul> <p>卸载阶段: componentWillUnmount 清除定时器，卸载Dom事件</p> <p>16.3版本 变化
去除： componentWillMount、componentWillReceiveProps、componentWillUpdate
增加：</p> <ul><li>static getDerivedStateFromProps(props, state)
<ul><li>挂载阶段render前执行</li> <li>更新阶段: props更新后直接执行（16.3）、setState()调用后及forceUpdate()调用后执行（16.4）</li></ul></li> <li>getSnapshotBeforeUpdate(prevProps, prevState)
<ul><li>更新阶段render()后执行</li></ul></li></ul> <h2 id="新生命周期"><a href="#新生命周期" class="header-anchor">#</a> 新生命周期</h2> <ul><li>挂载
<ul><li>constructor</li> <li>getDerivedStateFromProps</li> <li>render</li> <li>componentDidMount</li></ul></li> <li>更新
<ul><li>getDerivedStateFromProps</li> <li>shouldComponentUpdate</li> <li>render</li> <li>getSnapshotBeforeUpdate</li> <li>componentDidUpdate</li></ul></li> <li>卸载</li> <li>componentWillUnmount</li></ul> <h2 id="组件渲染过程"><a href="#组件渲染过程" class="header-anchor">#</a> 组件渲染过程</h2> <p>总结：父组件调用render之后开始执行子组件对应周期（首次渲染render、父组件状态修改触发render）的方法，等子组件对应周期的方法执行完之后，再执行父组件的后续方法。</p> <ul><li>挂载阶段，只有当执行到render的时候，子组件的constructor才开始执行，直到子组件挂载完成（componentDidMount），父组件才算挂载完成</li> <li>更新阶段，类似挂载阶段，只有父组件执行到render，才开始子组件的getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render，但再父组件的getSnapshotBeforeUpdate是紧随在子组件的getSnapshotBeforeUpdate后，然后子组件在componentDidUpdate</li> <li>父组件调用forceUpdate，组件调用forceUpdate方法后，不会执行shouldComponentUpdate，会执行getDerivedStateFromProps，然后再render，后面的生命周期和更新一致</li></ul> <h2 id="context"><a href="#context" class="header-anchor">#</a> context</h2> <p>作用： 当你不想在组件树种逐层传递props和state时，可以使用context跨层传递数据。</p> <h2 id="在哪里调用请求"><a href="#在哪里调用请求" class="header-anchor">#</a> 在哪里调用请求</h2> <p>componentDidMount中调用</p> <ul><li>比在componentWillMoun中调用节省的时间非常少</li> <li>服务端渲染will执行两次</li> <li>fiber后，will可能中断</li> <li>will会被废弃</li></ul> <h2 id="为何会废弃-componentwillmount、-componentwillreceiveprops、-componentwillupdate"><a href="#为何会废弃-componentwillmount、-componentwillreceiveprops、-componentwillupdate" class="header-anchor">#</a> 为何会废弃 componentWillMount、 componentWillReceiveProps、 componentWillUpdate</h2> <ul><li>三个函数都是执行在render之前，fiber架构会中断执行，导致多次执行</li> <li>React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码
<ul><li>componentWillMount可以完全适应componentDidMount和constructor来代替</li> <li>componentWillReceiveProps新的替代方法是静态方法，没有this，写不出副作用</li></ul></li></ul> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> fiber</h2></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">更新于:</span> <span class="time">2023/11/30</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/967ed7/"><div>preload&amp;prefetch</div></a> <span>09-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/2f93fe/"><div>webpack 概念</div></a> <span>09-04</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/d17ca6/"><div>项目基于Jenkins发版流程</div></a> <span>08-10</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2023
    <span>DBY</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9480acd0.js" defer></script><script src="/assets/js/2.60fa7d2d.js" defer></script><script src="/assets/js/8.f6479d16.js" defer></script>
  </body>
</html>