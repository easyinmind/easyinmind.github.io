---
title: 深浅拷贝
date: 2021-04-10 17:19:21
permalink: /pages/9d41c4/
categories:
  - 前端
tags:
  - 
---

## 赋值
> 不会在堆中开辟新空间，赋的值是内存地址，共享同一块内存，值类型和引用类型都相互影响  

```js
const a = {
  name: 'name',
  type: {
    age: 12
  }
}
const b = a
// name、type、属性都会相互影响
```
![](https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/20210412184620.png)

## 浅拷贝
> 在堆中开辟新空间，第一层的属性值类型互不影响，引用类型相互影响  

```js
const a = {
  name: 'name',
  type: {
    age: 12
  }
}
const b = a
// name不会项目影响
// type、age会相互影响
```
![](https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/20210412184642.png)
## 浅拷贝实现方式
1. Object.assign(): 等价`...`
2. 展开运算符`...`
3. Array.prototype.concat()
4. Array.prototype.slice()
5. lodash的_.clone

## 深拷贝
> 在堆中开辟新空间，值类型和引用类型相互不影响 

```js
const a = {
  name: 'name',
  type: {
    age: 12
  }
}
const b = a
// name、type、age不会相互影响
```
![](https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/20210412184706.png)

## 深拷贝实现方式
1. JSON.parse(JSON.stringify()): 不能处理函数和正则
2. lodash的_.cloneDeep
3. jQuery.extend()
4. 手动实现

## 手动实现深拷贝
```js
const obj = {
  a: 1,
  b: {
    b1: 'b1'
  },
  c: [1,2]
}
// 循环引用
obj.d = obj
// 这次调用没传map，默认创建一个新的Map实例
cloneDeep(obj)
function cloneDeep(obj, map = new Map()) {
  // 只有第一次调用会创建map，后续不会创建
  if(!map.size) {
    console.log("第一次调用，创建map", map)
  }else {
    console.log('map有值，是第一次创建的', map)
  }
  // obj：string/number/boolean/Symbol/undefined/function/null
  // 1 值类型和函数直接返回，不做深入拷贝
  if(typeof obj !== 'object' || obj === null) {
      return obj
  }
  // 2 判断需要拷贝的值是对象还是数组，并设置空值（可以增加其它类型：Map、Set）
  const result = Array.isArray(obj) ? [] : {}
  // 3 判断当值对象是否已经遍历过，如果已经遍历过说明是循环引用，不遍历直接返回
  if(map.get(obj)) {
      // obj.d 循环引用了 obj
      console.log('循环引用', obj)
      return map.get(obj)
  }
  // 4 将遍历过的对象放入 map（保证不会反复遍历）
  map.set(obj, result)
  // 5 遍历对象
  for(const k in obj) {
      // 6 判断是否是自有属性
      if(obj.hasOwnProperty(k)) {
          // 7 递归赋值，传入map（第一次调用时创建的map）
          result[k] = cloneDeep(obj[k], map) 
      } 
  }
  return result
}

// 第一次调用，创建map Map(0) {}
// map有值，是第一次创建的 Map(1) {{…} => {…}}
// map有值，是第一次创建的 Map(1) {{…} => {…}}
// map有值，是第一次创建的 Map(2) {{…} => {…}, {…} => {…}}
// map有值，是第一次创建的 Map(2) {{…} => {…}, {…} => {…}}
// map有值，是第一次创建的 Map(3) {{…} => {…}, {…} => {…}, Array(2) => Array(0)}
// map有值，是第一次创建的 Map(3) {{…} => {…}, {…} => {…}, Array(2) => Array(1)}
// map有值，是第一次创建的 Map(3) {{…} => {…}, {…} => {…}, Array(2) => Array(2)}
// 循环引用 {a: 1, b: {…}, c: Array(2)}
```

## 深拷贝实现思路及问题
> 通过递归遍历，值类型就直接返回，引用类型递归调用。通常只考虑基本类型和函数、数组、对象等常用的变量类型

1. 基本类型直接赋值
2. Array、Object通过遍历赋值拷贝
3. Function 不拷贝，如需拷贝使用 `eval`思路
4. 类型合理判断：`typeof`、`instanceof`、`Object.prototype.toString`、`Array.isArray`
5. 是否拷贝原型属性， `hasOwnProperty`判断
6. 循环引用，使用Map（引用类型可以作为key，即将每次传入的值作为Map的key，遍历前判断）判断。或者使用对象，将引用类型序列化为字符串作为key

## 递归深拷贝执行的流程
> 需要理解第一次调用深拷贝函数开始到结束，中间会再次调用N次深拷贝函数去处理嵌套的值。
1. 第一次调用传入值
2. 判断类型，值类型返回，引用类型遍历
3. 遍历引用类型的属性值，第二次传入属性值调用该方法
4. n次调用深拷贝函数...
5. 递归遍历所有嵌套属性，直至所有属性都为值类型
6. 第一次的调用结束，返回新的对象

