---
title: 数据类型相关知识点
date: 2021-04-06 10:32:49
permalink: /pages/f4fcfa/
categories:
  - JavaScript
tags:
  - 数据类型
---
## 概览
> 1. 值类型和引用类型有什么
> 2. 理解基本包装类型、装箱拆箱概念
> 3. 数据类型在内存中的存储方式
> 4. 类型判断的方法
> 5. 类型转换
## 数据类型
*ECMAScript* 定义了数据类型，分两大类：**原始数据类型**、**引用数据类型**
## 原始类型
> 值类型、基本数据类型
+ **Null**: 只有一个值`null`
+ **Undefined**: 只有一个值`undefined`
+ **String**: 一串表示文本值的字符序列
+ **Number**: 整数、浮点数、特殊值 -Infinity、+Infinity、NaN
+ **Boolean**: true、false
+ **Symbol**: 一种实例是唯一且不可改变的数据类型（ES6）
+ **BigInt**: 简单来说可以表示任意大的整数（ES10）

特性：基本数据类型的值是不可改变的，只能被替换（重新赋值）


## 引用类型
> 在js中，除了原始类型都是引用类型

**Object**引用类型包含了更具体的引用类型(子类型):
+ **Array**
+ **Function**
+ **Date**
+ **RegExp**
+ **Error**
+ **Arguments**
+ ...

![](https://cdn.jsdelivr.net/gh/easyinmind/cdn_file/blog/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

## 基本包装类型
> String、Number、Boolean

基本包装类型严格来说不属于原始数据类型和引用数据类，
但是又和两者有关系。

基本数据类型的值不是对象，不能有自己的方法和属性，但是
```js
const str = "str";
 // 1.创建基本包装类型 new String("str")，调用方法或属性
str.length;
// 2.上一行代码执行完了，销毁 new String("str") 实例
// 3.创建一个新的new String("str")实例，并添加color
str.color = "green" 
// 4.上一行代码执行完了，销毁 new String("str")实例
// 5.创建一个新的new String("str")实例，并获取color：undefined
console.log(str.color)
// 6.上一行代码执行完了，销毁 new String("str")实例
// 已上创建了三个 new String("str")实例，并在每行执行完之后销毁
// 在销毁前赋值给变量
const str2 = str.length
console.log(str2) // 3
```

每当读取一个基本类型的值的时候，后台就创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。  
1. 创建一个对应的的包装类型实例
2. 在实例上调用方法
3. 销毁实例

基本包装类型的对象和引用类型的对象最大的一个区别是，对象的生存期不同，导致的一个结果就是，基本包装类型无法自定义自己的方法属性。对于引用类型的数据，在执行流离开当前作用域之前都会保存在内存中，而对于自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，执行完毕就会立即被销毁。


## 装箱和拆箱操作
装箱：基本类型转为包装类型，为了调用对应的方法或者使用属性
```js
// 隐式装箱
let a = 'test'
let b = a.subString(2) // 会自动创建包装类型

// 显式装箱，通过new创建，创建的实例是引用类型
let aa = new String('test')
```
避免显示装箱，因为在后面的操作中你可能会不确定这个数据是什么类型

拆箱：引用类型转为基本类型，在工作中最常见的拆箱就是对两个不同类型的数据进行`==`比较
> 拆箱的过程一般会调用抽象操作[ToPrimitive],其内部主要的方法是valueOf和toString
+ 引用类型转换为非String类型，先调用valueOf，再调用toString
+ 引用类型转换为String类型，先调用toString，再调用valueOf
+ **toString** 方法返回一个字符串 "[object Object]"
+ **valueOf** 方法返回对象自身



## 数据类型在内存的存储
## 栈
> 值类型在创建的时候就由系统在栈中分配好固定的空间及大小  
> 由于栈中的内存空间的大小是固定的，所以存储在栈中的数据不可变  
**值类型**: 变量名 -> 具体值  
+ 存储的值大小固定
+ 空间较小
+ 可以直接操作其保存的变量，运行效率高
+ 由系统自动分配存储空间

## 堆
> 引用类型数据在栈中存储的只是固定长度的内存地址，具体值存储在堆中
**引用类型**: 变量名 -> 内存地址 -> 具体值  
+ 存储的值大小不定，可动态调整
+ 空间较大，运行效率低
+ 无法直接操作其内部存储，使用引用地址读取
+ 通过代码进行分配空间

## 复制、比较、数据传递
+ 复制：把一个变量的值复制给另一个变量，其实复制的都是栈中的值
  + 值类型复制的是具体值
  + 引用类型复制的是内存地址
+ 比较：数据类型比较也是比较栈中的值
  + 值类型比较具体值
  + 引用类型比较内存地址
+ 数据传递：函数进行数据传递的时候，传递的都是栈中的值
  + 值类型传递的是具体值
  + 引用类型传递的是内存地址

## 理解
基于数据类型和堆栈的特性，在一个数据创建的时候，js会判断如果是值类型，会把具体值存在栈中。
如果是引用类型会把具体值存在堆中，把对应的内存地址存在栈中。  
总结：复制、比较、数据传递所操作的都是栈中的值（值类型：具体值、引用类型：内存地址）

|  数据类型   |  栈空间   | 堆空间  |
|  ------  | -----  | -----  |
|  值类型  |  变量名：具体值  |    |
|  引用类型  | 变量名：内存地址  |  具体值 |

## 类型判断
## typeof
> 可以精准的判断**非null的基本类型**、**函数类型**  
> 除了函数，无法判断引用类型，返回值都为 object
```js
typeof 'ConardLi'  // string
typeof 123  // number
typeof true  // boolean
typeof Symbol()  // symbol
typeof undefined  // undefined
typeof function(){}  // function
```
## instanceof
> 可以判断引用类型的具体类型  
> 对象 instanceof 对象，语法规定两边都是对象
```js
[] instanceof Array // true
new Date() instanceof Date // true
new RegExp() instanceof RegExp // true
```
其实 instanceof 的判断规则为，数据是否在原型链上
```js
[] instanceof Array // true
[] instanceof Object // true
```
这样判断不是太准确，instanceof 的初衷并不是数据类型判断，也不能判断值类型数据

## Object.prototype.toString()
> 为何使用 Object.prototype上的toString，而不是Array、Date、RegExp。。。上的？  
> 因为Object.prototype.toString()被大部分引用类型继承，js重写了其它引用数据类型的toString，达不到效果
```js
const an = ['Hello','An'];
an.toString(); // "Hello,An"
```
Object.prototype.toString()方法返回 "[object type]"
```js
var toString=Object.prototype.toString;

console.log(toString.call(und));  // [object Undefined]
console.log(toString.call(nul));  // [object Null]
console.log(toString.call(boo));  // [object Boolean]
console.log(toString.call(num));  // [object Number]
console.log(toString.call(str));  // [object String]
console.log(toString.call(obj));  // [object Object]
console.log(toString.call(arr));  // [object Array]
console.log(toString.call(fun));  // [object Function]
console.log(toString.call(date));  // [object Date]
console.log(toString.call(reg));  // [object RegExp]
console.log(toString.call(err));  // [object Error]
console.log(toString.call(arg));  // [object Arguments]
```
不能精准判断自定义对象，对于自定义对象只会返回[object Object]，常用于判断浏览器内置对象

## 数据类型判断封装
> 为何Object.prototype.toString能判断所有数据类型，还需要 typeof，考虑性能方面
```js
function getType(value) {
  if(typeof value !== "object") {
    // 值类型判断
    return typeof value 
  }
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase()
}
```
## 其它
**注意**：Array.isArray() ie8 不支持，可以增加Object.prototype.toString兼容。
instanceof 遇到 跨页面（iframe）判断无效。

## 类型转换
> 装箱和拆箱其实就是一种类型转换  
> [更多参考](https://javascript.ruanyifeng.com/grammar/conversion.html)
+ **强制转换**
  + Number()
  + String()
  + Boolean()
+ **自动转换**

## if语句和逻辑语句
> 语句中只有单个变量时，下面数据会转为 false，其它转为 true
+ null
+ undefined
+ ''
+ NaN
+ 0
+ false

## 数学运算符
**- * /**: 非加运算会把其它类型转为数字  

**+**: 加运算
1. 有string时会把另一个转为字符串拼接
2. number+值类型，会把值类型转为number
3. number+引用类型，会把两个数据都转为字符串拼接
```js
123 + '123' // 123123   （规则1）
123 + null  // 123    （规则2）
123 + true // 124    （规则2）
123 + {}  // 123[object Object]    （规则3）

```


## 两等`==`

1. **NaN**: NaN和其他任何类型比较永远返回false(包括和他自己)
```js
NaN == NaN // false
```
2. **Boolean**: Boolean和其他任何类型比较，Boolean首先被转换为Number类型。
```js
true == 1  // true 1 == 1
true == '2'  // false 1 == '2'
true == ['1']  // true 1 == ["1"]
true == ['2']  // false 1 == ["2"]

// false先转为0，undefined 和 null和任何类型比较都为false
undefined == false // false undefined == 0
null == false // false null == false

```
3. **String 和 Number**: String和Number比较，先将String转换为Number类型
```js
123 == '123' // true
'' == 0 // true
```
4. **null和undefined**: 除了 `null == undefined`，任何比较都为false
```js
null == undefined // true
null == '' // false
null == 0 // false
null == false // false
undefined == '' // false
undefined == 0 // false
undefined == false // false
```
5. **原始类型 和 引用类型**: 引用类型按照 **ToPrimitive** 规则转换为原始类型
   + 引用类型转换为非String类型，先调用valueOf，再调用toString
   + 引用类型转换为String类型，先调用toString，再调用valueOf
   + 如果对象存在 toString() 并返回一个基本类型值，即返回这个值
   + 如果 toString() 不存在或返回的不是一个基本类型值，就调用 valueOf()
   + 如果 valueOf() 存在并返回一个基本类型值，即返回这个值
   + 如果 valueOf() 不存在或返回的不是一个基本类型值，则抛出 TypeError 异常
   + **toString** 方法返回一个字符串 "[object Object]"
   + **valueOf** 方法返回对象自身
   + 数组元素为null或undefined时，该元素被当做空字符串处理，所以`[null]`、`[undefined]`都会被转换为0


**总结**: 即拆箱操作会返回值类型，如果toString和valueOf都没返回值类型，则报错
```js
'[object Object]' == {} // true {}调用 toString
'1,2,3' == [1, 2, 3] // true [1,2,3]调用 toString

// 1. [null] == 0 boolean转为数字
// 2. [null]调用valueOf返回[null],在调用toString返回"", "" == 0
// 3. ""转为数字0，0 == 0
[null] == false // true
[undefined] == false // true 同上
```
## 面试题
```js
// 实现 a == 1 && a == 2 && a == 3
// a要转换为数字，会调用valueOf(),重写此方法，
// a == 1时，删除最后一个元素（1）并返回，这时a为[3,2]
// a == 2时，删除最后一个元素（2）并返回，这时a为[3]
// 以此类推，或者使用shift从前往后删除

const a = {
  value: [3,2,1],
  valueOf: function() {
    return this.value.pop();
  },
}
console.log(a == 1 && a == 2 && a == 3)
```
```js
[] == ![] // true
// !的优先级高于==，![]首先会被转换为false ==> [] == false
// false转换成Number类型0 [] == 0
// 左侧[]转换为0，两侧比较相等 0 == 0
```