---
title: React相关概念简述
date: 2021-06-15 11:50:37
permalink: /pages/7853cd/
categories:
  - 前端技术
tags:
  - 
---

## 类组件和函数组件（无状态组件、展示组件）
函数组件相比类组件，性能要稍高一些，因为类组件需要实例化，函数组件直接执行即可。  
函数组件没有`state`、`生命周期`及`this`。注：react hooks除外

## 受控组件和非受控组件
控制组件，针对表单来说。  
受控组件需要将表单的value值于state绑定，并通过change事件setState，改变state的值。由React控制值，在改变的过程中可以对值进行处理。   
非受控组件，不进行state的绑定，通过真实dom获取表单元素的value值，使用ref或者form 的 submit事件里获取。使用表单本身的状态逻辑，由 DOM 处理表单数据的地方，而不是在 React 组件中。  
尽量使用受控组件。


## 高阶组件HOC（纯组件）
接受一个组件并返回一个新的组件；   
+ 渲染劫持
+ 代码重用

## 异步组件
通过import()

## 构造函数调用super并传入props
> 区别在于构造函数内调用super之后能不能使用this.props
```js
class MyComponent extends React.Component {
  constructor(props) {
    // super();
    // console.log(this.props);  // undefined
    // console.log(props);  // 有值

    // super(props);
    // console.log(this.props);  // 有值
    // console.log(props);  // 有值
  }
  render(){
    console.log(this.props) // 有值，super()与super(props)在构造函数外部不受影响
  }
}

```

## state/props
都是js对象，state是组件自己管理的数据，可变。props是外部传入的数据，不可变。   
有state的组件是有状态组件，无state的组件是无状态组件。  
多用无状态组件。  

## JSX
React发布提出的语法（模板语法？），将html和js结合，浏览器不认识，需要webpackbabel转为js。 

## 避免组件重新渲染
React.memo() 防止函数组件不必要的渲染；   
PureComponent 防止类组件不必要的渲染； 
原理是通过传入组件的props进行浅比较，如果props没有改变则不渲染。使用不当会带来额外的性能开销。  
shouldcomponentupdate;

## setState同步异步

只要进入react的调度流程，就是异步的。setTimeout、setInterval、在DOM上绑定原生事件都不会进入React的调度流程。  
setState被调用后悔进入一个逻辑函数，判断当前react所处的阶段executionContext是否是 NoContext （空闲），如果是则会同步执行setState。
executionContext的初始值就是NoContext，所以只要不进入react的调度流程 setState就是同步的。    
useState与setSatet同理；

## 生命周期
初始化阶段: constructor()，在 constructor 中进行 state、props 的初始化，在这个阶段修改 state，不会执行更新阶段的生命周期，可以直接对 state 赋值   
挂载阶段: componentWillMount(未挂载 Dom) -> render -> componentDidMount(已经挂载 Dom)
更新阶段:  
+ componentWillReceiveProps(nextProps,nextState) state更新不会触发，props更新会触发。在这个方法中改变 state 不会二次渲染，而是直接合并 state。
+ shouldComponentUpdate(nextProps,nextState) 返回false会阻止向下的生命周期执行，默认返回true; 不能执行setState();
+ componentWillUpdate(nextProps,nextState) 不能执行setState();
+ render
+ componentDidUpdate(prevProps, prevState)

卸载阶段: componentWillUnmount 清除定时器，卸载Dom事件   

16.3版本 变化
去除： componentWillMount、componentWillReceiveProps、componentWillUpdate
增加： 
+ static getDerivedStateFromProps(props, state) 
  + 挂载阶段render前执行
  + 更新阶段: props更新后直接执行（16.3）、setState()调用后及forceUpdate()调用后执行（16.4）
+ getSnapshotBeforeUpdate(prevProps, prevState)
  + 更新阶段render()后执行
  
## 新生命周期
+ 挂载
  + constructor
  + getDerivedStateFromProps
  + render
  + componentDidMount
+ 更新
  + getDerivedStateFromProps
  + shouldComponentUpdate
  + render
  + getSnapshotBeforeUpdate
  + componentDidUpdate
+ 卸载
 + componentWillUnmount


## 组件渲染过程
总结：父组件调用render之后开始执行子组件对应周期（首次渲染render、父组件状态修改触发render）的方法，等子组件对应周期的方法执行完之后，再执行父组件的后续方法。
+ 挂载阶段，只有当执行到render的时候，子组件的constructor才开始执行，直到子组件挂载完成（componentDidMount），父组件才算挂载完成  
+ 更新阶段，类似挂载阶段，只有父组件执行到render，才开始子组件的getDerivedStateFromProps -> shouldComponentUpdate -> render，但再父组件的getSnapshotBeforeUpdate是紧随在子组件的getSnapshotBeforeUpdate后，然后子组件在componentDidUpdate
+ 父组件调用forceUpdate，组件调用forceUpdate方法后，不会执行shouldComponentUpdate，会执行getDerivedStateFromProps，然后再render，后面的生命周期和更新一致

## context
作用： 当你不想在组件树种逐层传递props和state时，可以使用context跨层传递数据。  


## 在哪里调用请求
componentDidMount中调用
+ 比在componentWillMoun中调用节省的时间非常少
+ 服务端渲染will执行两次
+ fiber后，will可能中断
+ will会被废弃

## 为何会废弃 componentWillMount、 componentWillReceiveProps、 componentWillUpdate
+ 三个函数都是执行在render之前，fiber架构会中断执行，导致多次执行
+ React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码
  + componentWillMount可以完全适应componentDidMount和constructor来代替
  + componentWillReceiveProps新的替代方法是静态方法，没有this，写不出副作用
  

## fiber

