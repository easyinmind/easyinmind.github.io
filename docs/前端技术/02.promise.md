---
title: promise
date: 2021-04-19 18:32:44
permalink: /pages/897f4f/
categories:
  - 前端技术
tags:
  - 
---


## Promise
> 社区出现的异步编程解决方案，现已被纳入ES6规范
## 概念
Promise是一个构造函数，接收函数作为参数，该函数内的两个参数resolve、reject由js引擎提供，该函数会立即执行，返回一个promise实例。   
resolve 是把promise的状态从pendind改为resolved； reject 是把promise的状态从rejected改为resolved；  
通常reject的参数是Error的实例，表示抛出错误。resolve参数是正常的值或者另一个Promise实例，如果是正常值，后续的then使用自己的状态，如果是另一个Promise实例，后续的then则使用返回的这个Promise得状态，如果这个状态是pending则等待，否则then会立即执行。
```js
// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail


// 调用resolve或reject并不会终结 Promise 的参数函数的执行，需要return一下
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```
## 常用方法
1. **Promise.prototype.then**：改变promise状态的回调，第一个回调是成功回调，第二个是失败回调（通常不写这个，而是通过catch捕获）。返回一个新的promise对象。
2. **Promise.prototype.catch**：失败回调，`then(null/undefined, rejection)`的别名。在catch之前的then的回调函数抛出的错误`throw new Error('test')`和`reject(err)`都能捕获。
3. **Promise.prototype.finally**：无论成功失败总会调用，并且总是返回原来的值。
4. **Promise.all**：（所有都成功）把多个promise实例包装成一个新的promise实例，所有实例状态为成功返回一个数组（多个primise实例），有一个实例状态是失败返回的实例。作为参数的实例如果有自己的catch方法，则不会触发all的catch方法。
5. **Promise.allSettled**：（所有都完成），不论成功失败。该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。
```js
const resolved = Promise.resolve(2);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  // 状态总是成功
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 2 },
//    { status: 'rejected', reason: -1 }
// ]
```
6. **Promise.race**：（有一个成功）把多个promise实例包装成一个新的promise实例，返回第一个改变状态的实例。
```js
// 如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
```
7. **Promise.any**：（有一个完成）
8. **Promise.resolve**：将现有对象转为 Promise 对象，根据参数不同分如下几种转换方式
   1. 参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例
   2. thenable对象，指的是具有then方法的对象。将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。
    ```js
    let thenable = {
      then: function(resolve, reject) {
        resolve(42);
      }
    };

    let p1 = Promise.resolve(thenable);
    p1.then(function (value) {
      console.log(value);  // 42
    });
    ```
   3. 参数不是具有then()方法的对象，或根本就不是对象。返回一个新的 Promise 对象，状态为resolved。
   4. 不带有任何参数，直接返回一个resolved状态的 Promise 对象
9.  **Promise.reject**：返回一个新的 Promise 实例，该实例的状态为rejected。参数，会原封不动地作为reject的理由，变成后续方法的参数。
```js
Promise.reject('出错了')
.catch(e => {
  console.log(e === '出错了')
})
// true
```

